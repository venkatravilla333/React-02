                                        ========

1) What is React?
   ==============


    1) React is an open-source javaScript library for building user interfaces (UIs). 

    2) It was developed by Facebook.

    3) React is a component based library.

    4) React is used for developing dynamic web applications, react can update and render efficiently when the underlying data changes.

    5) React uses virtual representation of DOM to efficiently update and render data in UI. Instead of directly manipulating the actual DOM, React calculates the minimal set of changes needed and updates the virtual DOM, which is efficiently applied to actual DOM.

    6) React utilizes JSX (JavaScript XML), It allows developers to write HTML-like syntax within JavaScript code. This helps developers for developing UI fast and easily.

    7) React follows a uni-directional data flow pattern, where data flows from parent components to child components via props. This makes the data flow predictable and helps to maintain clear data flow hierarchy.

    8) React can do only one thing that is it can render data fastly and efficiently in webpages.

    9) React provides the facility of integrating with other libraries, frameworks and languages easily to develop additional functionality.

    10) React works as a declarative library.

    11) React can develop single page applications by using react-router-dom library.



2) DOM Manipulation
   ================

   In Javascript
   -------------

    <script>

         var h1 = document.createElement('h1')

         h1.innerHTML = 'Hello react'

         var root = document.getElementById('root')

         root.appendChild(h1)

    </script>



    In React
    --------

     <script>

          var h1 = React.createElement('h1', {}, 'hello world')

          var root = ReactDOM.createRoot(document.getElementById('root'))

          root.render(h1)

     </script>



3) How to install react
   ====================


    Use React and ReactDOM library
    ------------------------------


    1) How to use react by using CDN links
       -----------------------------------

   <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
   <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>



    2) How to install react by using create-react-app tool
       ---------------------------------------------------

      => Here by default webpack will be installed (This is also a build tool)

      => npx create-react-app app-name

      => cd app-name

      => npm start



    3) How to install react by using vite tool
       ---------------------------------------

      - Vite is one of the most popular build tools out there in market.

      - Vite is a build tool that aims to provide a faster development.

      - Vite makes Hot module raplacement.

      - Vite also allows us to select the framework we want to work.

      => npm create vite@latest .

      => npm i

      => npm run dev



4) Folder structure in react
   =========================


node_modules
------------

 - "node_modules" refers to the external libraries and packages that your React application depends on. These modules are managed by a package manager like npm.
 
 - With a package manager like npm, you can use a single command (npm install) to automatically download and install all the dependencies specified in your project's package.json file.

 - No need to send this file to github, it can be generated by using npm install command. So put this folder in .gitignore file. 

public folder
-------------

 - In React.js, the "public" folder is a special directory that contains static assets and files that should be publicly accessible to the client-side of your application.

 - The purpose of the "public" folder is to provide a place for assets that don't need to go through the build process. Unlike the "src" folder, which contains the source code of your React application and gets processed by Webpack and Babel, the "public" folder assets are copied as-is to the build output directory during the build process. 

   index.html file:
   ---------------
 
 - This is the main HTML file that serves as the entry point to your React application. It contains a <div> element with an id='root', which acts as the mount point for the React components. 


src folder
----------
  
 - It's important to note that the "src" folder contains the source code that will be processed and bundled by build tools like webpack, vite and others to create a production-ready version of your application.
 
 - During development, you work in the "src" folder, and the build process outputs the optimized and minified code into a separate "build" or "dist" folder that you can deploy.

   - App.js file:
     -----------
     It is the root/ parent component created by default.

   - main/index.js file:
     ------------------
     This is the linking file, in this file we link root(App) component to index.html file.
     App component will be rendered in div element of index.html file. 
    

package.json
------------

 - It contains a dependencies that lists all the external libraries and packages that your project depends on. 
 - When you or someone else clones your project and runs npm install, npm reads the package.json file and installs all the listed dependencies along with their specified versions.

package.lock.json
-----------------

 - To summarize, the package-lock.json file and the package.json file work together to manage dependencies, ensure version consistency, provide reproducibility, and enhance the security and integrity of your React.js project.
 
 - It's important to commit both the package-lock.json and the package.json files to version control systems like Git, so others can have a consistent development environment when working on the project.

.gitignore
----------

 - The .gitignore file in a React project is used to specify which files and directories should be ignored by the version control system, such as Git.  

   In a React project, some typical entries you might find in the .gitignore file include:

 - Build Output: Ignore the output directories where the bundled and minified code is generated. These directories are usually named "build" or "dist."

 - Node_Modules: Ignore the "node_modules" directory, which contains all installed dependencies. Since dependencies can be easily re-installed using the package manager there is no need to include them in the version control system.

 - Environment Variables: Ignore files that store sensitive information, such as API keys, passwords, or configuration files specific to your development environment.



5) Components
   ==========


   1) What is component?
      =================

   1) A component is a reusable block of code, it contains a piece of user interface (UI).

   2) User Interface (UI) is a collection of components in react.

   3) Components are re-usable. 
               
   4) Components can maintain state in it and can receive props from parent and return JSX.

   5) Components return JSX, JSX contains UI.

   6) Components can render dynamic data in UI by using props and state.
   
   7) Components can be composed together by nesting them within each other or passing them as props to other components, creating a hierarchy of UI elements. This modular approach allows for reusability, maintainability, and separation of concerns in React applications.



   2) Types of components in react?
      ============================

    In React there are two types of components.
 
    1) Class component:
       ---------------

    - A class component is a type of component that is defined using ES6 classes and extends the React.Component class from React.

    - It can maitain state in it and can receive props from parent and return JSX.

    - It has a constructor where the initial state can be defined.

    - The render method is a compulsory method in a class component. Render method returns the JSX that defines the component's UI.
      
    - In class components we have to bind "this" keyword when we handle with events.

    - Class components can't undersand by browser which need to be converted into pure javascript by using Babel (Transpiler).

      
    2) Functional component:
       --------------------

    - A functional component is a type of component that is defined using JavaScript function.

    - It can maitain state in it and can receive props from parent and return JSX.
 
    - The function body returns the JSX that defines the component's UI.
    
    - No need of constructor and render() method and "this" key word in functional components.

    - Functional component is a javascript function which can be undersand by browser easily. No need of conversion.

    - After introduction of hooks functional components are not stateless. By using useSate hook we can maintain state in functional component.

    - Functional components are simpler and more lightweight compared to class components. 


6) JSX (Javascript & XML)
   =====================

    - JSX (JavaScript & XML) is used in React.js for defining and rendering the UI. 

    - It allows developers to write HTML-like syntax within JavaScript code. This helps developers for developing UI fast and easily.
   
    - Under the hood, JSX is transformed into regular JavaScript code by a process called transpiling. Tools like Babel are used to transpile JSX code into JavaScript code that 
      the browser can understand.
 
    - The transpiled code uses React.createElement() function to create and update the actual DOM elements.

    - JSX allows you to embed JavaScript expressions within curly braces {}. This enables you to dynamically compute and insert values, variables, or expressions into your JSX code. 

    - Using of JSX is a common practice in React development, it is not mandatory. React can also work without JSX by using the React.createElement() function directly.

    - Take a look at the below code:

      let jsx = <h1>This is JSX</h1>

    - This is simple JSX code in React. But the browser does not understand this JSX because it's not valid JavaScript code. This is because we're assigning an HTML tag to a variable that is not a string but just HTML code.

    - So to convert it to browser understandable JavaScript code, we use a tool like Babel which is a JavaScript transpiler.
  
      The React.createElement has the following syntax:

      React.createElement(type, [props], [...children])

      Let’s look at the parameters of the createElement function.

        *type can be an HTML tag like h1, div or it can be a React component.
        *props are the attributes you want the element to have.
        *children contain other HTML tags or can be a component. 

    - When we have two or more jsx sibling elements, JSX will through an error.

      const App = () => {
        return (
          <p>This is first JSX Element!</p>
          <p>This is another JSX Element</p>
          );
        };

     Here We will get an error

     Solutions to resolve issue:
     --------------------------- 

     1) To make it work, the obvious solution is to wrap both of them in some parent element, most probably a div.

     2) You can try returning it as an array as shown below:

         const App = () => {
           return (
                 [<p>This is first JSX Element!</p>,<p>This is another JSX Element</p>]
                )
              };

     3) The other way to fix it is by using the React.Fragment component:

         const App = () => {
            return (
              <React.Fragment>
              <p>This is first JSX Element!</p>
              <p>This is another JSX Element</p>
              </React.Fragment>
              );
            };

     - Fragments let you group a list of children without adding extra nodes to the DOM.


   **Following are the valid things you can have in a JSX Expression:

   - A string like "hello"
   - A number like 10
   - An array like [1, 2, 4, 5]
   - An object property that will evaluate to some value
   - A function call that returns some value which may be JSX
   - A map method that always returns a new array
   - JSX itself
      

   **Following are the invalid things and cannot be used in a JSX Expression:

   - A for loop or while loop or any other loop
   - A variable declaration
   - A function declaration
   - An if condition
   - An object
   - undefined, null, and boolean are not displayed on the UI when used inside JSX.

   Summary:
   -------

   - Every JSX tag is converted to React.createElement call and its object representation.
   - JSX Expressions, which are written inside curly brackets, allow only things that evaluate to some value like string, number, array map method and so on.
   - In React, we have to use className instead of class for adding classes to the HTML element
   - All attribute names in React are written in camelCase.
   - undefined, null, and boolean are not displayed on the UI when used inside JSX.


   7) Props
   =====

   1. In ReactJS, "props" short for properties, it is a way for passing data from a parent component to its child components.
 
   2. Props allow you to make your components dynamic and reusable by providing them with the necessary data from their parent components.

   3. Props are read-only (immutable) meaning that the child components should not modify the props directly. If a child component needs to modify the data, ((it should be done by sending a callback function from the parent component as a prop.))

   4. Props promote the flow of data from top to bottom in the component hierarchy, following the unidirectional data flow principle of React.

     Here's how it works:

   - Parent Component: In the parent component, you define a child component and pass data to it using attributes. These attributes are referred to as props in the child component.
   
   - Child Component: In the child component, you can access the data passed from parent through the props object.

   

   1) Parent to child 

   2) Child to parent

   3) Child to child (between siblings)

      1) Child to parent & parent to child

      2) Context API

      3) Redux
  

8) State
   =====


   1. In React, "state" is a pre-defined variable for managing and storing data within a component. Unlike props, which are passed from parent to child components and props are read-only, where as state is used for storing data that can change over time and is maintained and managed within the component itself.

   2. State is an essential concept in React and is widely used for creating dynamic and interactive user interfaces.

   3. A React component's state is used to store and manage data that can change over time. When the state of a component changes, React will automatically re-render the component, updating the user interface to reflect the new state.

   4. To use state in a class-based component, you can define the initial state in the constructor using this.state. In functional components, you can use the useState hook to create and manage state variables.

  
 
   1) What is local state?
      ===================

   - In React, "local state" refers to the state that is confined and managed within a specific component. It means that the state data is not accessible by other components in the application.

   - useState:

     useState is a built-in React Hook that allows functional components to have local state.
     It is used for managing simple state within a component without the need for complex state management solutions.
     Use useState when you have local state that is limited to a single component.

   
     1) class components

      this.state = {}

      this.setState()

     2) functional components

      simple data
      -----------

      useState hook

      complex data
      ------------

      useReducer hook



   2) What is state lifting?
      =====================

  - State lifting, also known as "lifting state up," is a pattern in React where the state data is moved from a child component to its parent component in the component hierarchy. This is done to share the state between multiple child components.

  - The need for state lifting typically arises when two or more components need to share the same state. Instead of maintaining the state separately in each child component, the state is moved to a common parent component.
 
  - The parent component then passes down the state data and any necessary callback functions as props to the child components, allowing them to interact with and update the shared state.


   3) What is props drilling?
      ======================


  - Props drilling is a term used in React to describe the process of passing data (props) from a higher-level component down to one or more nested child components through multiple levels of the component tree.

  - This process of passing the same prop through multiple intermediary components is known as props drilling.


    Props drilling typically occurs when ?
    --------------------------------------

  - Data needs to be shared between distant components: If two components are not directly connected through parent-child relationships, but they need to exchange data, the data must be passed through intermediary components using props drilling.

  - Intermediate components do not use the data themselves: Sometimes, components in the middle of the component tree don't need the data they receive as props. However, since they are required to pass the data down to their child components, they act as channel for passing data, leading to props drilling.


    While props drilling is a natural and common pattern in React applications, it can lead to a couple of issues:

   1) Prop drilling can make the code harder to maintain and read, especially when there are many levels of nesting.

   2) If the data needs to be accessed by a deeply nested component, all the intermediate components must receive and pass down the data, even if they don't use it, which can be inefficient.


    4) How to avoid props drilling in react?
       ====================================

   - By maintaining global state we can avoid props drilling.

   - To address these issues, you can consider using state management libraries like Redux or the React Context API to manage and share data across components without the need for explicit props drilling.
 
   - These libraries offer centralized stores or contexts that allow components to access data without passing it through every level of the component tree.

       
    5) What is Global state?
       ====================

   - In ReactJS, "global state" refers to a centralized state management approach where the application's state is stored and managed in a global container and made accessible to any component in the application.
 
   - This global state can be accessed from any component without the need to pass data through props or props drilling.

   - The motivation behind using global state is to simplify the process of sharing data between different components, especially when multiple components need access to the same data. It helps avoid the complexity arise from excessive props drilling.

     There are various libraries and approaches available in React to implement global state:


     1) React Context API:
        ----------------- 

    - The React Context API is a built-in feature that allows you to create a context and share data through the component tree without explicit props passing.

    - The Context API in React allows you to store and share any value that you want, including primitive data types (like numbers and strings), objects, arrays, functions, or even React components. It's not limited to specific data types.
 
    - It enables you to define a Provider component at the top level of the application to provide data, and then any component within the provider's scope can consume that data using the useContext hook.

    - When you create a context using React.createContext(), you can provide an initial value that will be used when a component accesses the context without a matching provider.

    - Basically, Context API consists of two main components: the context provider and the context consumer. The provider is responsible for creating and managing the context, which holds the data to be shared between components. On the other hand, the consumer is used to access the        context and its data from within a component.

      Steps:

        1) Create a Context Object:
 
           First, you need to create a context object using the createContext function from the 'react' library. This context object will hold the data that you want to share across your application.

           
        2) Wrap Components with a Provider:

           Once you've created a context object, you need to wrap the top level components that need access to the shared data with a Provider component. The Provider component accepts a "value" prop that holds the shared data, and any component that is a child of the Provider component can access that shared data.

        3) Consume context value:

           In class components: render props pattern

           In functional components: useContext hook

     Note: Avoid using it for state that only needs to be accessed within a single component, as it can lead to unnecessary complexity and performance issues.


     2) Redux:
        -----

    - Redux is a popular state management library for React applications. It provides a global store that holds the application's state, and any component can access the state and dispatch actions to update the state.
 
    - Redux follows a unidirectional data flow, making it easier to manage and track state changes in large applications.

      Core principles in redux:

       1) Action: Action is an object with type property.
   
       2) Reducer: Reducer is a function it receives initialState and action and it return new state depends upon action.

       3) Store: We can create store by using createStore () method which is from redux.

      
    2) Redux:
        -----

    - Redux is a popular state management library for React applications. It provides a global store that holds the application's state, and any component can access the state and dispatch actions to update the state.
 
    - Redux follows a unidirectional data flow, making it easier to manage and track state changes in large applications.

      Core principles in redux:

       1) Action: Action is an object with type property.
   
       2) Reducer: Reducer is a function it receives initialState and action and it return new state depends upon action.

       3) Store: We can create store by using createStore () method which is from redux.

React-redux
-----------

React-Redux is a library for integrating the React library with the Redux state management library in a React application. React is a JavaScript library for building user interfaces, and Redux is a predictable state container for JavaScript apps, commonly used with React for managing the state of a web application in a more organized and scalable way.

Here are the main components and concepts in React-Redux:

Provider: 
-------

Wraps the entire React application and makes the Redux store available to all components in the component tree.

connect() Function: 
------------------

React-Redux provides a connect() function that creates container components. These container components are responsible for connecting React components to the Redux store. The connect() function takes two main arguments: mapStateToProps and mapDispatchToProps. These functions define how to retrieve state from the Redux store and how to dispatch actions.

The connect function is a crucial part of the React-Redux library, and it is used to connect a React component to the Redux store. It is a higher-order function (HOC) that wraps your component and provides it with the necessary props to interact with the Redux store.

Here's how the connect function is typically used:


import { connect } from 'react-redux';

// Define a React component

class MyComponent extends React.Component {
  // Your component logic here
}

// Define a function to map state from the Redux store to component props

const mapStateToProps = (state) => {
  return {
    // Map state properties to component props
    someProp: state.someProp,
    anotherProp: state.anotherProp,
  };
};

// Define a function to map dispatch actions to component props

const mapDispatchToProps = (dispatch) => {
  return {
    // Map action creators to component props
    someAction: () => dispatch(someAction()),
    anotherAction: () => dispatch(anotherAction()),
  };
};

// Connect the component to the Redux store

export default connect(mapStateToProps, mapDispatchToProps)(MyComponent);

Here's a breakdown of the key parameters passed to the connect function:

mapStateToProps:
---------------
This function is used to map the state from the Redux store to the props of your component. It takes the current state as an argument and returns an object that defines the props your component needs.

mapDispatchToProps:
------------------
It is used to map action creators to the props of your component. It takes the dispatch function as an argument and returns an object with the mapped actions.

connect(mapStateToProps, mapDispatchToProps)(MyComponent):
----------------------------------------------------------
The connect function returns a new function that you can use to wrap your React component. The resulting connected component will receive the state and actions as props.
Once your component is connected using connect, it can access the Redux state and dispatch actions as props. For example:


// Inside MyComponent

console.log(this.props.someProp); // Accessing state

this.props.someAction(); // Dispatching an action

This pattern helps in creating components that are connected to the global Redux state, making it easy to manage and update the state in a React application.


In functional component
-----------------------

useSelector and useDispatch are two hooks provided by the React Redux library, which is commonly used for state management in React applications.

useSelector:
-----------

- useSelector is used to extract data from the Redux store.
- It takes a selector function as an argument, which is used to select a specific piece of data from the Redux store's state. 

useDispatch:
-----------

- useDispatch is used to dispatch actions to the Redux store.
- It returns a reference to the dispatch function from the Redux store.
- The dispatch function is used to send actions to the Redux store, triggering state changes.

In summary, useSelector is used to read data from the Redux store, and useDispatch is used to dispatch actions to update the state in the Redux store. Together, these hooks facilitate the integration of React components with the Redux state management system.

      
     Global state
     ------------

      1) class components

         -context API

         -redux

      2) functional components
          
         -Context API

         -redux


9) Performance?
   ===========
  

What is Conditional rendering?
=============================


   - Conditional rendering in React.js is the process of displaying different components or content based on certain conditions or state values.
 
   - It allows developers to control the output of the user interface based on specific conditions, such as user interactions, data availability, or component state changes.

     1) If statements: You can use regular JavaScript if else statements to conditionally render components or elements.

     2) Ternary operator: The ternary operator is a concise way to conditionally render content based on condition. It has condition ? expression1:expression2

     3) Logical && operator: In cases where you want to conditionally render content only when a certain condition is true, you can use the && operator.

   - Conditional rendering is a powerful concept in React because it enables developers to build dynamic and interactive user interfaces by showing different content based on the application's state and user interactions


What is Fragment?
================


   - In React.js, a Fragment is a special type of component that allows you to group multiple child elements without adding an extra DOM element.
 
   - It was introduced as a feature in React 16.2 to address the common use case where developers needed to return multiple elements from a component's render method without wrapping them in a parent element.

   - Prior to the introduction of Fragments, if you wanted to return multiple elements from a component, you had to wrap them inside a single parent element.

   - With Fragments, you can achieve the same result without introducing an extra <div> element.
 
   - By using Fragments, you keep your JSX cleaner and reduce the number of DOM elements, which can lead to better performance in some cases.

   - It's important to note that using Fragment doesn't add any additional functionality to your components; they are purely a syntax feature to make your JSX more concise and organized.


What is HOC?
===========


   - In simple terms, an HOC is a function that takes a component as input and returns a new component with additional props or behaviors.

   - The purpose of HOCs is to encapsulate and share common functionality across different components without the need for code duplication. It allows you to reuse component logic in your application.

   - They are commonly used for tasks like logging, authentication, authorization, and sharing state or behavior among multiple components.

   - It's worth noting that the React team has recommended using hooks (e.g., useState, useReducer, etc.) for managing local state within components, which makes HOCs less commonly used for state management in modern React applications. Hooks provide a more concise and straightforward approach for managing local state without the need for higher-order                components. However, HOCs can still be valuable for other scenarios like code reuse, logic separation, and wrapping third-party components.

  - HOCs can offer a more localized approach to state management, allowing you to encapsulate state logic within the component tree without relying on a global state container. 

  - Global state management in React can be achieved using various tools and libraries like Redux, MobX, or React Context API. However, using HOCs is another approach that allows you to share state and functionality across multiple components in a more localized manner.

  - By using this approach, you can manage the state in a more localized and composable way, making it easier to understand and maintain your code. Keep in mind that if your application's  state management requirements grow complex, using dedicated state management libraries like Redux or MobX might still be a more suitable solution.



What is render props pattern?
============================

   - The tern 'render prop' refers to a technique for sharing common logic between react components by using prop whose value is a function.


What is custom hook?
===================


   - In React.js, a "Custom Hook" is a JavaScript function that allows you to encapsulate reusable logic and stateful behavior to be shared across different components.

   - Custom Hooks are powerful because they allow you to abstract complex logic and state management into separate units of functionality, making your components cleaner, more focused, and easier to maintain.
 
   - They also promote code sharing and prevent duplication of logic across different components.

   - Custom Hooks follow a specific naming convention by starting the function name with the prefix "use." For example, a custom hook for handling state might be named useCustomState, and one for fetching data might be named useCustomFetch.

     

What is Virtual DOM?
===================

 - In React.js, the Virtual DOM is a lightweight, in-memory representation of the actual DOM in the browser. It is a key concept in React's rendering process and plays a crucial role in optimizing the performance of React applications.

 - When you create a React component, you define its structure using JSX,React takes these JSX components and converts them into Virtual DOM representation.

   Here's how the Virtual DOM works:

  1) Component rendering (Create the Virtual DOM Tree:): When you render a React component, React creates a Virtual DOM tree that mirrors the structure of your JSX components.

  2) State/props changes: When there's a change in the application's state or props, a new Virtual DOM tree is generated for the updated component and its children. This represents the desired state of the UI.

  3) Virtual DOMs comparison (Diffing:): React then compares the new Virtual DOM tree with the previous one to determine the minimal number of changes needed to update the actual DOM.

  4) Recursive Comparison: During the diffing process, React compares nodes in both Virtual DOM trees. It checks whether a node is different between the two trees based on its type (e.g, HTML element, functional component, class component) and its key (if provided). If the type or key is different, React considers the nodes to be different and proceeds to update that part of the tree.

  4) Reconciliation: After calculating the differences, React applies the necessary updates only to the real DOM nodes that require changes. This process of updating only the specific parts of the DOM is known as "reconciliation" and is much more efficient than directly updating the      entire DOM.

  5) Actual DOM update: Finally, React applies the "diff" to the real DOM in a single batch update, avoiding excessive direct manipulation of the DOM, which can be slow and resource-intensive.

  - In summary, the Virtual DOM is an essential part of React's rendering process that acts as a middle layer between your React components and the actual DOM, optimizing performance by efficiently updating only the necessary parts of the DOM.


What is Pure component?
======================


   - It is a specific type of React component that automatically implements shouldComponentUpdate () with shallow comparison of props and state to determine whether the component should re-render or not.

   - By default, when a component receives new props or updates its state, React will trigger a re-render of that component and its child components. 

   - However, in some cases, the new props or state might be the same as the previous ones, and the component doesn't need to re-render because it would produce the same output.

   - A Pure Component optimizes this process by doing a shallow comparison of the current and previous props and state.
 
   - If React determines that the new props and state are equal to the previous ones, it will skip the re-rendering process for that component and its children, saving unnecessary rendering cycles.

   - To create a Pure Component in React, you can extend the React.PureComponent class instead of React.Component.


       1) Class components

          => conditional rendering

          => Fragment

          => HOC
    
          => Render props pattern

          => Pure component

      

What is React.memo() in react?
=============================


   - React.memo is a higher-order component (HOC) provided by React that is used for optimizing functional components by preventing unnecessary re-renders.
 
   - It is similar to React.PureComponent for class components, but it is specifically designed to work with functional components.

   - By default, when a functional component is re-rendered, it re-executes its entire function body, potentially recalculating values and causing re-renders for its child components.
     In some cases, this can lead to performance issues, especially when the component receives the same props and its rendering output would be identical.

   - React.memo optimizes this process by memoizing the component's result and re-rendering it only when its props change. It performs a shallow comparison of the current and previous props, and if they are equal, the component is not re-rendered, and the previously memoized result is used.

   - When you wrap a functional component with React.memo, it will only re-render if its props have changed since the last render. If the props are the same, React will skip the rendering process for that component, preventing unnecessary re-renders and improving performance.

   

What is useMemo ()  hook?
========================


   - In React.js, useMemo is a hook that is used for memoizing expensive computations, preventing unnecessary recalculation of values on each render.
 
   - It allows you to cache the result of a function call and return the cached result when the inputs (dependencies) to that function have not changed since the last render.

   - The useMemo hook takes two arguments: the first argument is the function that computes the value you want to memoize, and the second argument is an array of dependencies. 
 
   - The hook will recompute the value only when one of the dependencies in the array has changed. If the dependencies remain the same between renders, useMemo will return the cached value, avoiding redundant calculations.


What is useCallback hook?
=========================


   - In React.js, useCallback is a hook that is used to memoize functions in order to avoid unnecessary re-creations of those functions on every render.
 
   - It is particularly useful when dealing with child components that receive functions as props, as re-creating functions can cause those child components to re-render unnecessarily, leading to performance issues.

     The useCallback hook takes two arguments:

     1) The function that you want to memoize.

     2) An array of dependencies. The memoized callback will only be re-created when any of the dependencies in the array change.

   - Using useCallback is beneficial when dealing with components that receive functions as props, as it can prevent those components from re-rendering needlessly and improve overall performance.

   Summary:
   -------
   
   - A class component that implements either one or both of the life cycle methods static getDerivedStateFromError or componentDidCatch becomes an error boundry component.

   - The static getDerivedStateFromError method is used to render fallback UI after an error is thrown.

   - The componentDidCatch method is used to log error info in console. 



       2) Functinal components

          => conditional rendering

          => Fragment

          => custom hooks

          => React.memo

          => useMemo

          => useCallback


8) Life cycle methods in class components
   ======================================


     1) Mounting phase

     2) Updating phase
   
     3) Unmounting phase

     4) Error boundry


In React.js, components have a lifecycle that consists of different phases during their creation, updating, and destruction. However, with the introduction of React Hooks, some of the traditional lifecycle methods have been replaced or complemented by new functions. Here is an overview of both the traditional class component lifecycle methods and the corresponding React Hook equivalents:

Class Component Lifecycle Methods:
----------------------------------

1)Mounting Phase:
  --------------

1) constructor(props): Initializes the component's state and binds event handlers.

2) static getDerivedStateFromProps(props, state): Used to update the state based on changes in props. Rarely used.

3) render(): Renders the component's UI.

4) componentDidMount(): Invoked immediately after the component is mounted to the DOM. Perfect for side effects like network requests.

2) Updating Phase:
   --------------

1) static getDerivedStateFromProps(nextProps, prevState): Similar to the mounting phase method, but for updates.

2) shouldComponentUpdate(nextProps, nextState): Determines if the component should re-render, optimizing performance.

3) render(): Renders the updated UI.

4) getSnapshotBeforeUpdate(prevProps, prevState): Captures some information before the component update.

5) componentDidUpdate(prevProps, prevState, snapshot): Invoked after the component update is flushed to the DOM. Useful for side effects.

3) Unmounting Phase:
   ----------------

1) componentWillUnmount(): Invoked just before the component is unmounted and destroyed. Clean up resources here.

4) Error Handling Phase:
   --------------------

componentDidCatch(error, info): Used for error boundaries to catch and handle errors within a component's children.

React Hook Equivalents:
-----------------------

Mounting Phase:
--------------

useState(initialState): Equivalent to setting state in the constructor.
useEffect(callback, dependencies): Equivalent to componentDidMount. 

Updating Phase:
--------------

useEffect(callback, dependencies): Still used for updates and side effects.


Unmounting Phase:
----------------

useEffect(() => () => cleanup, []): Cleanup function to be executed when the component unmounts.


Error Handling Phase:
--------------------

In React functional components, error handling is typically done using a combination of error boundaries and standard JavaScript error handling techniques. Error boundaries are components that catch JavaScript errors anywhere in their child component tree and display an error UI instead of crashing the whole application. Here's how you can handle errors in functional components in React:

Use try...catch Blocks: You can use standard JavaScript try...catch blocks within your functional component to catch errors that occur during rendering or other operations.

Use Error Boundaries: Error boundaries are special components that catch errors from their child components. You can define an error boundary component and wrap your functional component with it.

Use Custom Error Handling Hooks: You can create custom hooks to handle errors in functional components and provide a consistent way of handling errors throughout your application.

import React, { useState } from 'react';

function useErrorHandling() {
  const [error, setError] = useState(null);

  const handleError = (error) => {
    setError(error);
    console.error(error);
  };

  return { error, handleError };
}

function MyComponent() {
  const { error, handleError } = useErrorHandling();

  try {
    // Your component logic here
    return <div>{someData}</div>;
  } catch (error) {
    handleError(error);
    return <div>An error occurred: {error.message}</div>;
  }
}
Remember that error boundaries can only catch errors in their child components during rendering. They won't catch errors in event handlers, async code (e.g., setTimeout), or when errors are thrown outside the component tree. For those cases, you may still need to use traditional try...catch blocks or other error-handling techniques.

Additionally, make sure to provide helpful error messages and notifications to users when errors occur, but avoid showing too much technical detail that could potentially expose vulnerabilities.



9) Side Effects (DOM interaction/ Browser interaction/ API calls)
=================================================================

     1) class components

        =>componentDidMount
        =>componentDidUpdate
        =>componentWillUnmount

     2) functional components

        =>useEffect hook

useEffect hook:
==============

The useEffect hook is a fundamental part of React functional components that allows you to perform side effects in your components. Side effects can include things like data fetching, DOM manipulation. It's used to handle the lifecycle aspects of a component, similar to how lifecycle methods (componentDidMount, componentDidUpdate, and componentWillUnmount) work in class components.


10) refs
    ====

   - In class components we use React.createRef() 

   - In functional components we use useRef hook 
   
   - It is used to access/refer DOM elements in react.

   - By using ref we can also store data in react and it can also update value between re-renders without re-rendering the component.
 
   - The updated value will be tracked by react but component will not be re-rendered. 
     For storing value in react we have state variable.

   - The value will persist through the re-renders while also not causing any additional renders when its value changes.

   - The main purpose of ref variable in react to interact with DOM.

     


11) Portals
    =======

    
  - Portal is an advanced concept in reacts which provides a way to render child element outside of parent DOM hierarchy.

  - If any child component having modal/popup/tooltip in its JSX then its parent component's css will be effected.

  - To implement a portal in React, you use the ReactDOM.createPortal() method. This method allows you to specify the content you want to render and the target DOM element where it should be inserted.

       - Create one more div in index.html file to render child component in which modal develops.

              <div id='model-root'></div>

       - In child component JSX use the below to create portal. 

            => ReactDOM.createPortal(modal, document.getElementById(model-root))

  - By using portals, you can achieve more flexibility in rendering elements and create better user experiences when it comes to managing overlapping or out-of-flow components in React applications.

   .modal-overlay {

    position: absolute;
    top:0;
    left:0;
    width: 100%;
    height: 100%;
    background-color:rgba(0, 0, 0, 0.5);
    z-index: 2;
    display: flex;
    justify-content: center;
    align-items: center;
  }

 .content {
  background-color: white;
  padding: 20px;
  border-radius: 5px;

  box-shadow: 0 2px 8px rgba(0 0 0 0.5)
  }

 /* .app {
      position: relative
    } */


